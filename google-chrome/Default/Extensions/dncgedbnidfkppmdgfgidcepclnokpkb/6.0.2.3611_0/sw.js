(()=>{var me=Object.defineProperty,At=Object.defineProperties;var Lt=Object.getOwnPropertyDescriptors;var He=Object.getOwnPropertySymbols;var qt=Object.prototype.hasOwnProperty,Pt=Object.prototype.propertyIsEnumerable;var Qe=(t,e,r)=>e in t?me(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,g=(t,e)=>{for(var r in e||(e={}))qt.call(e,r)&&Qe(t,r,e[r]);if(He)for(var r of He(e))Pt.call(e,r)&&Qe(t,r,e[r]);return t},O=(t,e)=>At(t,Lt(e)),Mt=t=>me(t,"__esModule",{value:!0});var fe=(t,e)=>()=>(t&&(e=t(t=0)),e);var Ut=(t,e)=>{Mt(t);for(var r in e)me(t,r,{get:e[r],enumerable:!0})};var Pe,Rt,$t=fe(()=>{Pe={"session-ready-for-data-collection":()=>"","page-attributes":()=>"","set-experiment-name":({name:t})=>`name=${t}`,"sparkline-for-column":({baseColId:t,traceColId:e,pixelWidth:r})=>`baseColId=${t}, traceColId=${e}, pixelWidth=${r}`,"data-share-source":({sourceId:t})=>`sourceId=${t}`,"create-new-dataset":[t=>{let{name:e,type:r}=t;return`name=${e}, type=${r}`},t=>{let{dataSetId:e,foreignId:r}=t;return`dataSetId=${e}, foreignId=${r}`}],"create-new-column":[t=>{let{dataSetId:e,name:r,units:s}=t;return`dataSetId=${e}, name=${r}, units=${s}`},t=>{let{columnId:e,foreignId:r}=t;return`columnId=${e}, foreignId=${r}`}],"create-user-manual-column":t=>{let{name:e,unit:r,dataType:s}=t;return`name=${e}, unit=${r}, dataType=${s}`},"create-user-calc-column":t=>{let{name:e,unit:r,calcEquation:s}=t;return`name=${e}, unit=${r}, calcEquation=${s}`},"remove-column-group":({groupId:t})=>`groupId=${t}`,"update-dataset-properties":t=>{let{id:e}=t;return`id=${e}`},"update-column-group":t=>{let{groupId:e,name:r,units:s}=t;return`groupId=${e}, name=${r}, units=${s}`},"update-column-values":({id:t,values:e,trim:r})=>{let s=e.map(o=>`${o}`).join("\\n");return`id=${t}, trim=${r}\\n${s}`},"change-column-data-type":({id:t,type:e})=>`id=${t}, type=${e}`,"add-event-data":({id:t,value:e,readings:r})=>{let s=r.map(o=>`${o}`).join("\\n");return`id=${t}, value=${e}]
${s}`},"change-column-unit":({id:t,unit:e})=>`id=${t}, unit=${e}`,"change-column-properties":({id:t,color:e,symbol:r})=>`id=${t}, color=${e}, symbol=${r}`,"add-graph":[()=>"",({graphId:t})=>`graphId=${t}`],"set-meter-visibility":({visible:t})=>`visible=${t}`,"set-table-visibility":({visible:t})=>`visible=${t}`,"change-graph":({graphId:t,type:e})=>`graphId=${t}, type=${e} ...`,"add-graph-traces":({graphId:t,traces:e})=>{let r=e.map(s=>`baseColumnId=${s.baseColumnId}, traceColumnId=${s.traceColumnId}, isRightAxisTrace=${s.isRightAxisTrace}`).join("\\n");return`graphId=${t}\\n${r}`},"remove-graph-traces":({graphId:t,traces:e})=>{let r=e.map(s=>`baseColumnId=${s.baseColumnId}, traceColumnId=${s.traceColumnId}, isRightAxisTrace=${s.isRightAxisTrace}`).join("\\n");return`graphId=${t}\\n${r}`},"add-graph-curve-fit":({graphId:t,fitId:e,fitType:r,baseColumnId:s,traceColumnId:o})=>`graphId=${t}, fitId=${e}, fitType=${r}, baseColumnId=${s}, traceColumnId=${o}`,"remove-graph-curve-fit":({fitId:t})=>`fitId=${t}`,"add-graph-integral":({graphId:t,integralId:e,baseColumnId:r,traceColumnId:s})=>`graphId=${t}, integralId=${e}, baseColumnId=${r}, traceColumnId=${s}`,"remove-graph-integral":({integralId:t})=>`integralId=${t}`,"add-or-change-graph-peak-integral":t=>{let{graphId:e,integralId:r,baseColumnId:s,traceColumnId:o}=t;return`graphId=${e}, integralId=${r}, baseColumnId=${s}, traceColumnId=${o}`},"remove-graph-peak-integral":({integralId:t})=>`integralId=${t}`,"add-graph-stats":t=>{let{graphId:e,statsId:r,baseColumnId:s,traceColumnId:o}=t;return`graphId=${e}, statsId=${r}, baseColumnId=${s}, traceColumnId=${o}`},"remove-graph-stats":({statsId:t})=>`statsId=${t}`,"add-graph-annotation":t=>{let{parentId:e,annotationId:r}=t;return`parentId=${e}, annotationId=${r}`},"remove-graph-annotation":({annotationId:t})=>`annotationId=${t}`,"create-data-mark":t=>{let{dataSetId:e,duringCollection:r,traceColumnIds:s,text:o,rowIndex:n}=t;return`dataSetId=${e}, duringCollection=${r}, traceColumnIds=${s.join(" ")}, text=${o}, rowIndex=${n}`},"update-data-mark":t=>{let{dataSetId:e,duringCollection:r,traceColumnIds:s,text:o,rowIndex:n}=t;return`dataSetId=${e}, duringCollection=${r}, traceColumnIds=${s.join(" ")}, text=${o}, rowIndex=${n}`},"delete-data-mark":({dataMarkId:t})=>`dataMarkId=${t}`,"remove-dataset":({datasetId:t})=>`datasetId=${t}`,"check-recovery-file":()=>"","document-age":()=>"",export:({name:t,format:e,filepath:r,decimal:s,age:o})=>`name=${t}, format=${e}, filepath=${r}, decimal=${s}, age=${o}`,import:({path:t,format:e,content:r})=>`path=${t}, format=${e}, content=<${r.length} bytes>`,"document-meta-data":({path:t,format:e,content:r})=>`path=${t}, format=${e}, content=<${r.length} bytes>`,"set-session-subtype":({subtype:t})=>`subtype=${t}`,"set-notes-state":({text:t,visible:e})=>`text="${t}", visible=${e}`,"get-notes-state":()=>"","set-custom-curve-fit":({name:t,expression:e})=>`name=${t}, expression=${e}`,"get-custom-curve-fits":()=>"","get-calc-column-functions":()=>"","add-aux-graph":({parentGraphId:t,auxGraphType:e})=>`parentGraphId=${t}, auxGraphType=${e}`,"update-aux-graph":({auxGraphId:t})=>`auxGraphId=${t}`,"delete-aux-graph":({auxGraphId:t})=>`auxGraphId=${t}`},Rt={"dw:data-set-added":t=>`id=${t.id}, name=${t.name}, type=${t.type}`,"dw:data-set-ready":t=>`id=${t.id}`,"dw:data-set-removed":t=>`id=${t.id}`,"dw:data-column-added":t=>`id=${t.id}, groupId=${t.groupId}, dataSetId=${t.dataSetId}, type=${t.type}`,"dw:data-column-removed":t=>`id=${t.id}`,"dw:data-column-updated":t=>`id=${t.id}`,"dw:data-set-updated":t=>{var e;return`id=${t.id}', name=${(e=t.name)!=null?e:""}`},"dw:unit-change-finished":t=>`columnId=${t.columnId}`,"dw:data-set-row-added":t=>t.map(r=>{let{dataSetId:s}=r,{rowIndex:o}=r,{count:n}=r;return`dataSetId=${s}, rowIndex=${o}, count=${n}`}).join("\\n"),"dw:data-column-values-updated":t=>t.map(r=>{let{columnId:s,rows:o,values:n,wholeColumnFlag:a}=r,i=[];for(let u=0;u<Math.min(o.length,n.length);u++)i.push(`row=${o[u]}, value=${n[u]}`);return`columnId=${s}, wholeColumn=${a}\\n${i.join("\\n")}`}).join("\\n"),"dw:data-column-live-readout-changed":t=>{let{columnId:e,value:r}=t;return`columnId=${e}, value=${r}`},"dw:data-graph-updated":t=>`index=${t.index}, type=${t.type}`,"dw:data-annotation-updated":t=>`id=${t.annotationId}`,"dw:data-video-updated":()=>"","dw:data-group-added":t=>{let{id:e,name:r,units:s,type:o}=t;return`id=${e}, name=${r}, units=${s} type=${o}`},"dw:data-group-removed":t=>`id=${t.id}`,"dw:data-group-properties-changed":t=>`id=${t.id} ...`,"dw:session-started":()=>"","dw:document-age-updated":()=>"","gc-collection-started":()=>"","collection-ended":()=>"","complete-collection":()=>"","trigger-reached":()=>"","prestore-reached":()=>"","replay-engine-update":()=>""}});var Me,kt,Dt=fe(()=>{Me={"start-bluetooth-discovery":()=>"","stop-bluetooth-discovery":()=>"","start-labquest-stream-discovery":()=>"","stop-labquest-stream-discovery":()=>"","connect-bluetooth-device":({deviceId:t})=>`deviceId=${t}`,"disconnect-device":({deviceId:t})=>`deviceId=${t}`,"enable-device-channel":({deviceId:t,channelId:e,enable:r})=>`deviceId=${t}, channelId=${e}, enable=${r}`,"identify-device":({deviceId:t})=>`deviceId=${t}`,"get-gdxdevice-map":({deviceId:t})=>`deviceId=${t}`,"write-device-attributes":({deviceID:t,attributes:e})=>{let r=e.map(s=>`id=${s.attribID}, value=${s.value}`).join("\\n");return`deviceID=${t}\\n${r}`},"start-calibration-process":({deviceId:t,processId:e})=>`deviceId=${t}, processId=${e}`,"start-calibration-step":({deviceId:t,processId:e,stepId:r,inputValue:s})=>`deviceId=${t}, processId=${e}, stepId=${r}, inputValue=${s}`,"update-calibration-step":({deviceId:t,processId:e,stepId:r,inputValue:s})=>`deviceId=${t}, processId=${e}, stepId=${r}, inputValue=${s}`,"stop-calibration-step":({deviceId:t,processId:e,stepId:r,keep:s})=>`deviceId=${t}, processId=${e}, stepId=${r}, keep=${s}`,"stop-calibration-process":({deviceId:t,processId:e,keep:r})=>`deviceId=${t}, processId=${e}, keep=${r}`,"reset-factory-calibration":({deviceId:t})=>`deviceId=${t}`,"using-factory-calibration":({deviceId:t})=>`deviceId=${t}`},kt={"devmgr:bluetooth-available":({available:t})=>`available=${t}`,"devmgr:bluetooth-device-discovered":t=>{let{id:e,name:r,type:s}=t;return`id=${e}, name=${r}, type=${s} ...`},"devmgr:bluetooth-device-removed":({id:t})=>`id=${t}`,"devmgr:bluetooth-device-updated":t=>{let{id:e,name:r,type:s}=t;return`id=${e}, name=${r}, type=${s} ...`},"devmgr:usb-device-added":t=>{let{id:e,name:r,type:s}=t;return`id=${e}, name=${r}, type=${s} ...`},"devmgr:usb-device-removed":({id:t})=>`id=${t}`,"devmgr:usb-device-updated":t=>{let{id:e,name:r,type:s}=t;return`id=${e}, name=${r}, type=${s} ...`},"devmgr:calibration-step-result":({id:t,result:e})=>{let{value:r,success:s}=e;return`id=${t}, value=${r}, success=${s}`},"devmgr:device-attributes-changed":({deviceId:t,deviceAttributes:e})=>{let{id:r,type:s,value:o,description:n}=e;return`deviceId=${t}, attrib: id=${r}, type=${s}, value=${o}, description="${n}" ...`}}});var Ue={};Ut(Ue,{RPCLogger:()=>It});var kr,Dr,Ir,Tr,Sr,It,Ve=fe(()=>{$t();Dt();kr=t=>(Object.keys(t).forEach(e=>{let r=t[e];if(Array.isArray(r)){let[s]=r;t[e]=s}}),t),Dr=t=>{let e={};return Object.keys(t).forEach(r=>{let s=t[r];if(Array.isArray(s)){let[,o]=s;e[r]=o}}),e},Ir=kr(g(g({},Pe),Me)),Tr=Dr(g(g({},Pe),Me)),Sr=g(g({},Rt),kt),It=class{constructor(){this.emptyHandler=()=>"",this.startTime=Date.now(),this.msgLog=[]}get msgTimestamp(){return Date.now()-this.startTime}logRequest(e,r,s){var n;let o=(n=Ir[s.method])!=null?n:this.emptyHandler;this.msgLog.push(`${e}->${r}: [${this.msgTimestamp}] Request[${s.id}]: **${s.method}** ${o(s.params)}`)}logErrorResponse(e,r,s,o){this.msgLog.push(`${e}-#red>${r}: [${this.msgTimestamp}] Error[${o.id}]: **${s}**: ${o.error.message}`)}logResponse(e,r,s,o){var a;if(o.error){this.logErrorResponse(e,r,s,o);return}let n=(a=Tr[s])!=null?a:this.emptyHandler;this.msgLog.push(`${e}->${r}: [${this.msgTimestamp}] Response[${o.id}]: **${s}** ${n(o.result)}`)}logNotification(e,r,s){var n;let o=(n=Sr[s.method])!=null?n:this.emptyHandler;this.msgLog.push(`${e}--#darkgrey>${r}: [${this.msgTimestamp}] Notification: **${s.method}** ${o(s.params)}`)}getLogString(){return this.msgLog.join(`
`)}clearLog(){this.msgLog.length=0}}});"use strict";try{self["workbox:core:6.5.1"]&&_()}catch(t){}var Ge={"invalid-value":({paramName:t,validValueDescription:e,value:r})=>{if(!t||!e)throw new Error("Unexpected input to 'invalid-value' error.");return`The '${t}' parameter was given a value with an unexpected value. ${e} Received a value of ${JSON.stringify(r)}.`},"not-an-array":({moduleName:t,className:e,funcName:r,paramName:s})=>{if(!t||!e||!r||!s)throw new Error("Unexpected input to 'not-an-array' error.");return`The parameter '${s}' passed into '${t}.${e}.${r}()' must be an array.`},"incorrect-type":({expectedType:t,paramName:e,moduleName:r,className:s,funcName:o})=>{if(!t||!e||!r||!o)throw new Error("Unexpected input to 'incorrect-type' error.");let n=s?`${s}.`:"";return`The parameter '${e}' passed into '${r}.${n}${o}()' must be of type ${t}.`},"incorrect-class":({expectedClassName:t,paramName:e,moduleName:r,className:s,funcName:o,isReturnValueProblem:n})=>{if(!t||!r||!o)throw new Error("Unexpected input to 'incorrect-class' error.");let a=s?`${s}.`:"";return n?`The return value from '${r}.${a}${o}()' must be an instance of class ${t}.`:`The parameter '${e}' passed into '${r}.${a}${o}()' must be an instance of class ${t}.`},"missing-a-method":({expectedMethod:t,paramName:e,moduleName:r,className:s,funcName:o})=>{if(!t||!e||!r||!s||!o)throw new Error("Unexpected input to 'missing-a-method' error.");return`${r}.${s}.${o}() expected the '${e}' parameter to expose a '${t}' method.`},"add-to-cache-list-unexpected-type":({entry:t})=>`An unexpected entry was passed to 'workbox-precaching.PrecacheController.addToCacheList()' The entry '${JSON.stringify(t)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`,"add-to-cache-list-conflicting-entries":({firstEntry:t,secondEntry:e})=>{if(!t||!e)throw new Error("Unexpected input to 'add-to-cache-list-duplicate-entries' error.");return`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${t} but different revision details. Workbox is unable to cache and version the asset correctly. Please remove one of the entries.`},"plugin-error-request-will-fetch":({thrownErrorMessage:t})=>{if(!t)throw new Error("Unexpected input to 'plugin-error-request-will-fetch', error.");return`An error was thrown by a plugins 'requestWillFetch()' method. The thrown error message was: '${t}'.`},"invalid-cache-name":({cacheNameId:t,value:e})=>{if(!t)throw new Error("Expected a 'cacheNameId' for error 'invalid-cache-name'");return`You must provide a name containing at least one character for setCacheDetails({${t}: '...'}). Received a value of '${JSON.stringify(e)}'`},"unregister-route-but-not-found-with-method":({method:t})=>{if(!t)throw new Error("Unexpected input to 'unregister-route-but-not-found-with-method' error.");return`The route you're trying to unregister was not  previously registered for the method type '${t}'.`},"unregister-route-route-not-registered":()=>"The route you're trying to unregister was not previously registered.","queue-replay-failed":({name:t})=>`Replaying the background sync queue '${t}' failed.`,"duplicate-queue-name":({name:t})=>`The Queue name '${t}' is already being used. All instances of backgroundSync.Queue must be given unique names.`,"expired-test-without-max-age":({methodName:t,paramName:e})=>`The '${t}()' method can only be used when the '${e}' is used in the constructor.`,"unsupported-route-type":({moduleName:t,className:e,funcName:r,paramName:s})=>`The supplied '${s}' parameter was an unsupported type. Please check the docs for ${t}.${e}.${r} for valid input types.`,"not-array-of-class":({value:t,expectedClass:e,moduleName:r,className:s,funcName:o,paramName:n})=>`The supplied '${n}' parameter must be an array of '${e}' objects. Received '${JSON.stringify(t)},'. Please check the call to ${r}.${s}.${o}() to fix the issue.`,"max-entries-or-age-required":({moduleName:t,className:e,funcName:r})=>`You must define either config.maxEntries or config.maxAgeSecondsin ${t}.${e}.${r}`,"statuses-or-headers-required":({moduleName:t,className:e,funcName:r})=>`You must define either config.statuses or config.headersin ${t}.${e}.${r}`,"invalid-string":({moduleName:t,funcName:e,paramName:r})=>{if(!r||!t||!e)throw new Error("Unexpected input to 'invalid-string' error.");return`When using strings, the '${r}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${t}.${e}() for more info.`},"channel-name-required":()=>"You must provide a channelName to construct a BroadcastCacheUpdate instance.","invalid-responses-are-same-args":()=>"The arguments passed into responsesAreSame() appear to be invalid. Please ensure valid Responses are used.","expire-custom-caches-only":()=>"You must provide a 'cacheName' property when using the expiration plugin with a runtime caching strategy.","unit-must-be-bytes":({normalizedRangeHeader:t})=>{if(!t)throw new Error("Unexpected input to 'unit-must-be-bytes' error.");return`The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was "${t}"`},"single-range-only":({normalizedRangeHeader:t})=>{if(!t)throw new Error("Unexpected input to 'single-range-only' error.");return`Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was "${t}"`},"invalid-range-values":({normalizedRangeHeader:t})=>{if(!t)throw new Error("Unexpected input to 'invalid-range-values' error.");return`The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was "${t}"`},"no-range-header":()=>"No Range header was found in the Request provided.","range-not-satisfiable":({size:t,start:e,end:r})=>`The start (${e}) and end (${r}) values in the Range are not satisfiable by the cached response, which is ${t} bytes.`,"attempt-to-cache-non-get-request":({url:t,method:e})=>`Unable to cache '${t}' because it is a '${e}' request and only 'GET' requests can be cached.`,"cache-put-with-no-response":({url:t})=>`There was an attempt to cache '${t}' but the response was not defined.`,"no-response":({url:t,error:e})=>{let r=`The strategy could not generate a response for '${t}'.`;return e&&(r+=` The underlying error is ${e}.`),r},"bad-precaching-response":({url:t,status:e})=>`The precaching request for '${t}' failed`+(e?` with an HTTP status of ${e}.`:"."),"non-precached-url":({url:t})=>`createHandlerBoundToURL('${t}') was called, but that URL is not precached. Please pass in a URL that is precached instead.`,"add-to-cache-list-conflicting-integrities":({url:t})=>`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${t} with different integrity values. Please remove one of them.`,"missing-precache-entry":({cacheName:t,url:e})=>`Unable to find a precached response in ${t} for ${e}.`,"cross-origin-copy-response":({origin:t})=>`workbox-core.copyResponse() can only be used with same-origin responses. It was passed a response with origin ${t}.`,"opaque-streams-source":({type:t})=>{let e=`One of the workbox-streams sources resulted in an '${t}' response.`;return t==="opaqueredirect"?`${e} Please do not use a navigation request that results in a redirect as a source.`:`${e} Please ensure your sources are CORS-enabled.`}};var Vt=(t,e={})=>{let r=Ge[t];if(!r)throw new Error(`Unable to find message for code '${t}'.`);return r(e)},Ke=Vt;var l=class extends Error{constructor(e,r){let s=Ke(e,r);super(s);this.name=e,this.details=r}};var Bt=(t,e)=>{if(!Array.isArray(t))throw new l("not-an-array",e)},Wt=(t,e,r)=>{if(typeof t[e]!=="function")throw r.expectedMethod=e,new l("missing-a-method",r)},Ft=(t,e,r)=>{if(typeof t!==e)throw r.expectedType=e,new l("incorrect-type",r)},Ht=(t,e,r)=>{if(!(t instanceof e))throw r.expectedClassName=e.name,new l("incorrect-class",r)},Qt=(t,e,r)=>{if(!e.includes(t))throw r.validValueDescription=`Valid values are ${JSON.stringify(e)}.`,new l("invalid-value",r)},Gt=(t,e,r)=>{let s=new l("not-array-of-class",r);if(!Array.isArray(t))throw s;for(let o of t)if(!(o instanceof e))throw s},d={hasMethod:Wt,isArray:Bt,isInstance:Ht,isOneOf:Qt,isType:Ft,isArrayOfClass:Gt};var c=(()=>{"__WB_DISABLE_DEV_LOGS"in self||(self.__WB_DISABLE_DEV_LOGS=!1);let t=!1,e={debug:"#7f8c8d",log:"#2ecc71",warn:"#f39c12",error:"#c0392b",groupCollapsed:"#3498db",groupEnd:null},r=function(n,a){if(self.__WB_DISABLE_DEV_LOGS)return;if(n==="groupCollapsed"&&/^((?!chrome|android).)*safari/i.test(navigator.userAgent)){console[n](...a);return}let i=[`background: ${e[n]}`,"border-radius: 0.5em","color: white","font-weight: bold","padding: 2px 0.5em"],u=t?[]:["%cworkbox",i.join(";")];console[n](...u,...a),n==="groupCollapsed"&&(t=!0),n==="groupEnd"&&(t=!1)},s={},o=Object.keys(e);for(let n of o){let a=n;s[a]=(...i)=>{r(a,i)}}return s})();"use strict";try{self["workbox:routing:6.5.1"]&&_()}catch(t){}var H="GET",ze=["DELETE","GET","HEAD","PATCH","POST","PUT"];var A=t=>t&&typeof t=="object"?(d.hasMethod(t,"handle",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),t):(d.isType(t,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),{handle:t});var $=class{constructor(e,r,s=H){d.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"match"}),s&&d.isOneOf(s,ze,{paramName:"method"}),this.handler=A(r),this.match=e,this.method=s}setCatchHandler(e){this.catchHandler=A(e)}};var Q=class extends ${constructor(e,r,s){d.isInstance(e,RegExp,{moduleName:"workbox-routing",className:"RegExpRoute",funcName:"constructor",paramName:"pattern"});let o=({url:n})=>{let a=e.exec(n.href);if(!!a){if(n.origin!==location.origin&&a.index!==0){c.debug(`The regular expression '${e.toString()}' only partially matched against the cross-origin URL '${n.toString()}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`);return}return a.slice(1)}};super(o,r,s)}};var h=t=>new URL(String(t),location.href).href.replace(new RegExp(`^${location.origin}`),"");var G=class{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{let{request:r}=e,s=this.handleRequest({request:r,event:e});s&&e.respondWith(s)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&e.data.type==="CACHE_URLS"){let{payload:r}=e.data;c.debug("Caching URLs from the window",r.urlsToCache);let s=Promise.all(r.urlsToCache.map(o=>{typeof o=="string"&&(o=[o]);let n=new Request(...o);return this.handleRequest({request:n,event:e})}));e.waitUntil(s),e.ports&&e.ports[0]&&s.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:r}){d.isInstance(e,Request,{moduleName:"workbox-routing",className:"Router",funcName:"handleRequest",paramName:"options.request"});let s=new URL(e.url,location.href);if(!s.protocol.startsWith("http")){c.debug("Workbox Router only supports URLs that start with 'http'.");return}let o=s.origin===location.origin,{params:n,route:a}=this.findMatchingRoute({event:r,request:e,sameOrigin:o,url:s}),i=a&&a.handler,u=[];i&&(u.push(["Found a route to handle this request:",a]),n&&u.push(["Passing the following params to the route's handler:",n]));let p=e.method;if(!i&&this._defaultHandlerMap.has(p)&&(u.push(`Failed to find a matching route. Falling back to the default handler for ${p}.`),i=this._defaultHandlerMap.get(p)),!i){c.debug(`No route found for: ${h(s)}`);return}c.groupCollapsed(`Router is responding to: ${h(s)}`),u.forEach(f=>{Array.isArray(f)?c.log(...f):c.log(f)}),c.groupEnd();let b;try{b=i.handle({url:s,request:e,event:r,params:n})}catch(f){b=Promise.reject(f)}let m=a&&a.catchHandler;return b instanceof Promise&&(this._catchHandler||m)&&(b=b.catch(async f=>{if(m){c.groupCollapsed(`Error thrown when responding to:  ${h(s)}. Falling back to route's Catch Handler.`),c.error("Error thrown by:",a),c.error(f),c.groupEnd();try{return await m.handle({url:s,request:e,event:r,params:n})}catch(j){j instanceof Error&&(f=j)}}if(this._catchHandler)return c.groupCollapsed(`Error thrown when responding to:  ${h(s)}. Falling back to global Catch Handler.`),c.error("Error thrown by:",a),c.error(f),c.groupEnd(),this._catchHandler.handle({url:s,request:e,event:r});throw f})),b}findMatchingRoute({url:e,sameOrigin:r,request:s,event:o}){let n=this._routes.get(s.method)||[];for(let a of n){let i,u=a.match({url:e,sameOrigin:r,request:s,event:o});if(u)return u instanceof Promise&&c.warn(`While routing ${h(e)}, an async matchCallback function was used. Please convert the following route to use a synchronous matchCallback function:`,a),i=u,(Array.isArray(i)&&i.length===0||u.constructor===Object&&Object.keys(u).length===0||typeof u=="boolean")&&(i=void 0),{route:a,params:i}}return{}}setDefaultHandler(e,r=H){this._defaultHandlerMap.set(r,A(e))}setCatchHandler(e){this._catchHandler=A(e)}registerRoute(e){d.isType(e,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),d.hasMethod(e,"match",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),d.isType(e.handler,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),d.hasMethod(e.handler,"handle",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.handler"}),d.isType(e.method,"string",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.method"}),this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new l("unregister-route-but-not-found-with-method",{method:e.method});let r=this._routes.get(e.method).indexOf(e);if(r>-1)this._routes.get(e.method).splice(r,1);else throw new l("unregister-route-route-not-registered")}};var P,K=()=>(P||(P=new G,P.addFetchListener(),P.addCacheListener()),P);function y(t,e,r){let s;if(typeof t=="string"){let n=new URL(t,location.href);{if(!(t.startsWith("/")||t.startsWith("http")))throw new l("invalid-string",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});let i=t.startsWith("http")?n.pathname:t,u="[*:?+]";new RegExp(`${u}`).exec(i)&&c.debug(`The '$capture' parameter contains an Express-style wildcard character (${u}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`)}let a=({url:i})=>(i.pathname===n.pathname&&i.origin!==n.origin&&c.debug(`${t} only partially matches the cross-origin URL ${i.toString()}. This route will only handle cross-origin requests if they match the entire URL.`),i.href===n.href);s=new $(a,e,r)}else if(t instanceof RegExp)s=new Q(t,e,r);else if(typeof t=="function")s=new $(t,e,r);else if(t instanceof $)s=t;else throw new l("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return K().registerRoute(s),s}var k={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:typeof registration!="undefined"?registration.scope:""},ge=t=>[k.prefix,t,k.suffix].filter(e=>e&&e.length>0).join("-"),Kt=t=>{for(let e of Object.keys(k))t(e)},z={updateDetails:t=>{Kt(e=>{typeof t[e]=="string"&&(k[e]=t[e])})},getGoogleAnalyticsName:t=>t||ge(k.googleAnalytics),getPrecacheName:t=>t||ge(k.precache),getPrefix:()=>k.prefix,getRuntimeName:t=>t||ge(k.runtime),getSuffix:()=>k.suffix};function Je(t,e){let r=new URL(t);for(let s of e)r.searchParams.delete(s);return r.href}async function Xe(t,e,r,s){let o=Je(e.url,r);if(e.url===o)return t.match(e,s);let n=Object.assign(Object.assign({},s),{ignoreSearch:!0}),a=await t.keys(e,n);for(let i of a){let u=Je(i.url,r);if(o===u)return t.match(i,s)}}var we=class{constructor(){this.promise=new Promise((e,r)=>{this.resolve=e,this.reject=r})}};var M=new Set;async function Ye(){c.log(`About to run ${M.size} callbacks to clean up caches.`);for(let t of M)await t(),c.log(t,"is complete.");c.log("Finished running callbacks.")}function J(t){return new Promise(e=>setTimeout(e,t))}"use strict";try{self["workbox:strategies:6.5.1"]&&_()}catch(t){}function X(t){return typeof t=="string"?new Request(t):t}var Y=class{constructor(e,r){this._cacheKeys={},d.isInstance(r.event,ExtendableEvent,{moduleName:"workbox-strategies",className:"StrategyHandler",funcName:"constructor",paramName:"options.event"}),Object.assign(this,r),this.event=r.event,this._strategy=e,this._handlerDeferred=new we,this._extendLifetimePromises=[],this._plugins=[...e.plugins],this._pluginStateMap=new Map;for(let s of this._plugins)this._pluginStateMap.set(s,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(e){let{event:r}=this,s=X(e);if(s.mode==="navigate"&&r instanceof FetchEvent&&r.preloadResponse){let a=await r.preloadResponse;if(a)return c.log(`Using a preloaded navigation response for '${h(s.url)}'`),a}let o=this.hasCallback("fetchDidFail")?s.clone():null;try{for(let a of this.iterateCallbacks("requestWillFetch"))s=await a({request:s.clone(),event:r})}catch(a){if(a instanceof Error)throw new l("plugin-error-request-will-fetch",{thrownErrorMessage:a.message})}let n=s.clone();try{let a;a=await fetch(s,s.mode==="navigate"?void 0:this._strategy.fetchOptions),c.debug(`Network request for '${h(s.url)}' returned a response with status '${a.status}'.`);for(let i of this.iterateCallbacks("fetchDidSucceed"))a=await i({event:r,request:n,response:a});return a}catch(a){throw c.log(`Network request for '${h(s.url)}' threw an error.`,a),o&&await this.runCallbacks("fetchDidFail",{error:a,event:r,originalRequest:o.clone(),request:n.clone()}),a}}async fetchAndCachePut(e){let r=await this.fetch(e),s=r.clone();return this.waitUntil(this.cachePut(e,s)),r}async cacheMatch(e){let r=X(e),s,{cacheName:o,matchOptions:n}=this._strategy,a=await this.getCacheKey(r,"read"),i=Object.assign(Object.assign({},n),{cacheName:o});s=await caches.match(a,i),s?c.debug(`Found a cached response in '${o}'.`):c.debug(`No cached response found in '${o}'.`);for(let u of this.iterateCallbacks("cachedResponseWillBeUsed"))s=await u({cacheName:o,matchOptions:n,cachedResponse:s,request:a,event:this.event})||void 0;return s}async cachePut(e,r){let s=X(e);await J(0);let o=await this.getCacheKey(s,"write");{if(o.method&&o.method!=="GET")throw new l("attempt-to-cache-non-get-request",{url:h(o.url),method:o.method});let m=r.headers.get("Vary");m&&c.debug(`The response for ${h(o.url)} has a 'Vary: ${m}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`)}if(!r)throw c.error(`Cannot cache non-existent response for '${h(o.url)}'.`),new l("cache-put-with-no-response",{url:h(o.url)});let n=await this._ensureResponseSafeToCache(r);if(!n)return c.debug(`Response '${h(o.url)}' will not be cached.`,n),!1;let{cacheName:a,matchOptions:i}=this._strategy,u=await self.caches.open(a),p=this.hasCallback("cacheDidUpdate"),b=p?await Xe(u,o.clone(),["__WB_REVISION__"],i):null;c.debug(`Updating the '${a}' cache with a new Response for ${h(o.url)}.`);try{await u.put(o,p?n.clone():n)}catch(m){if(m instanceof Error)throw m.name==="QuotaExceededError"&&await Ye(),m}for(let m of this.iterateCallbacks("cacheDidUpdate"))await m({cacheName:a,oldResponse:b,newResponse:n.clone(),request:o,event:this.event});return!0}async getCacheKey(e,r){let s=`${e.url} | ${r}`;if(!this._cacheKeys[s]){let o=e;for(let n of this.iterateCallbacks("cacheKeyWillBeUsed"))o=X(await n({mode:r,request:o,event:this.event,params:this.params}));this._cacheKeys[s]=o}return this._cacheKeys[s]}hasCallback(e){for(let r of this._strategy.plugins)if(e in r)return!0;return!1}async runCallbacks(e,r){for(let s of this.iterateCallbacks(e))await s(r)}*iterateCallbacks(e){for(let r of this._strategy.plugins)if(typeof r[e]=="function"){let s=this._pluginStateMap.get(r);yield n=>{let a=Object.assign(Object.assign({},n),{state:s});return r[e](a)}}}waitUntil(e){return this._extendLifetimePromises.push(e),e}async doneWaiting(){let e;for(;e=this._extendLifetimePromises.shift();)await e}destroy(){this._handlerDeferred.resolve(null)}async _ensureResponseSafeToCache(e){let r=e,s=!1;for(let o of this.iterateCallbacks("cacheWillUpdate"))if(r=await o({request:this.request,response:r,event:this.event})||void 0,s=!0,!r)break;return s||(r&&r.status!==200&&(r=void 0),r&&r.status!==200&&(r.status===0?c.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`):c.debug(`The response for '${this.request.url}' returned a status code of '${e.status}' and won't be cached as a result.`))),r}};var E=class{constructor(e={}){this.cacheName=z.getRuntimeName(e.cacheName),this.plugins=e.plugins||[],this.fetchOptions=e.fetchOptions,this.matchOptions=e.matchOptions}handle(e){let[r]=this.handleAll(e);return r}handleAll(e){e instanceof FetchEvent&&(e={event:e,request:e.request});let r=e.event,s=typeof e.request=="string"?new Request(e.request):e.request,o="params"in e?e.params:void 0,n=new Y(this,{event:r,request:s,params:o}),a=this._getResponse(n,s,r),i=this._awaitComplete(a,n,s,r);return[a,i]}async _getResponse(e,r,s){await e.runCallbacks("handlerWillStart",{event:s,request:r});let o;try{if(o=await this._handle(r,e),!o||o.type==="error")throw new l("no-response",{url:r.url})}catch(n){if(n instanceof Error){for(let a of e.iterateCallbacks("handlerDidError"))if(o=await a({error:n,event:s,request:r}),o)break}if(o)c.log(`While responding to '${h(r.url)}', an ${n instanceof Error?n.toString():""} error occurred. Using a fallback response provided by a handlerDidError plugin.`);else throw n}for(let n of e.iterateCallbacks("handlerWillRespond"))o=await n({event:s,request:r,response:o});return o}async _awaitComplete(e,r,s,o){let n,a;try{n=await e}catch(i){}try{await r.runCallbacks("handlerDidRespond",{event:o,request:s,response:n}),await r.doneWaiting()}catch(i){i instanceof Error&&(a=i)}if(await r.runCallbacks("handlerDidComplete",{event:o,request:s,response:n,error:a}),r.destroy(),a)throw a}};var w={strategyStart:(t,e)=>`Using ${t} to respond to '${h(e.url)}'`,printFinalResponse:t=>{t&&(c.groupCollapsed("View the final response here."),c.log(t||"[No response returned]"),c.groupEnd())}};var L=class extends E{async _handle(e,r){let s=[];d.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"makeRequest",paramName:"request"});let o=await r.cacheMatch(e),n;if(o)s.push(`Found a cached response in the '${this.cacheName}' cache.`);else{s.push(`No response found in the '${this.cacheName}' cache. Will respond with a network request.`);try{o=await r.fetchAndCachePut(e)}catch(a){a instanceof Error&&(n=a)}o?s.push("Got response from network."):s.push("Unable to get a response from the network.")}c.groupCollapsed(w.strategyStart(this.constructor.name,e));for(let a of s)c.log(a);if(w.printFinalResponse(o),c.groupEnd(),!o)throw new l("no-response",{url:e.url,error:n});return o}};var Z={cacheWillUpdate:async({response:t})=>t.status===200||t.status===0?t:null};var ee=class extends E{constructor(e={}){super(e);this.plugins.some(r=>"cacheWillUpdate"in r)||this.plugins.unshift(Z),this._networkTimeoutSeconds=e.networkTimeoutSeconds||0,this._networkTimeoutSeconds&&d.isType(this._networkTimeoutSeconds,"number",{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"constructor",paramName:"networkTimeoutSeconds"})}async _handle(e,r){let s=[];d.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"handle",paramName:"makeRequest"});let o=[],n;if(this._networkTimeoutSeconds){let{id:u,promise:p}=this._getTimeoutPromise({request:e,logs:s,handler:r});n=u,o.push(p)}let a=this._getNetworkPromise({timeoutId:n,request:e,logs:s,handler:r});o.push(a);let i=await r.waitUntil((async()=>await r.waitUntil(Promise.race(o))||await a)());c.groupCollapsed(w.strategyStart(this.constructor.name,e));for(let u of s)c.log(u);if(w.printFinalResponse(i),c.groupEnd(),!i)throw new l("no-response",{url:e.url});return i}_getTimeoutPromise({request:e,logs:r,handler:s}){let o;return{promise:new Promise(a=>{o=setTimeout(async()=>{r.push(`Timing out the network response at ${this._networkTimeoutSeconds} seconds.`),a(await s.cacheMatch(e))},this._networkTimeoutSeconds*1e3)}),id:o}}async _getNetworkPromise({timeoutId:e,request:r,logs:s,handler:o}){let n,a;try{a=await o.fetchAndCachePut(r)}catch(i){i instanceof Error&&(n=i)}return e&&clearTimeout(e),a?s.push("Got response from network."):s.push("Unable to get a response from the network. Will respond with a cached response."),(n||!a)&&(a=await o.cacheMatch(r),a?s.push(`Found a cached response in the '${this.cacheName}' cache.`):s.push(`No response found in the '${this.cacheName}' cache.`)),a}};var S=class extends E{constructor(e={}){super(e);this._networkTimeoutSeconds=e.networkTimeoutSeconds||0}async _handle(e,r){d.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"_handle",paramName:"request"});let s,o;try{let n=[r.fetch(e)];if(this._networkTimeoutSeconds){let a=J(this._networkTimeoutSeconds*1e3);n.push(a)}if(o=await Promise.race(n),!o)throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`)}catch(n){n instanceof Error&&(s=n)}if(c.groupCollapsed(w.strategyStart(this.constructor.name,e)),o?c.log("Got response from network."):c.log("Unable to get a response from the network."),w.printFinalResponse(o),c.groupEnd(),!o)throw new l("no-response",{url:e.url,error:s});return o}};var U=class extends E{constructor(e={}){super(e);this.plugins.some(r=>"cacheWillUpdate"in r)||this.plugins.unshift(Z)}async _handle(e,r){let s=[];d.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"handle",paramName:"request"});let o=r.fetchAndCachePut(e).catch(()=>{});r.waitUntil(o);let n=await r.cacheMatch(e),a;if(n)s.push(`Found a cached response in the '${this.cacheName}' cache. Will update with the network response in the background.`);else{s.push(`No response found in the '${this.cacheName}' cache. Will wait for the network response.`);try{n=await o}catch(i){i instanceof Error&&(a=i)}}c.groupCollapsed(w.strategyStart(this.constructor.name,e));for(let i of s)c.log(i);if(w.printFinalResponse(n),c.groupEnd(),!n)throw new l("no-response",{url:e.url,error:a});return n}};"use strict";try{self["workbox:cacheable-response:6.5.1"]&&_()}catch(t){}var x=class{constructor(e={}){if(!(e.statuses||e.headers))throw new l("statuses-or-headers-required",{moduleName:"workbox-cacheable-response",className:"CacheableResponse",funcName:"constructor"});e.statuses&&d.isArray(e.statuses,{moduleName:"workbox-cacheable-response",className:"CacheableResponse",funcName:"constructor",paramName:"config.statuses"}),e.headers&&d.isType(e.headers,"object",{moduleName:"workbox-cacheable-response",className:"CacheableResponse",funcName:"constructor",paramName:"config.headers"}),this._statuses=e.statuses,this._headers=e.headers}isResponseCacheable(e){d.isInstance(e,Response,{moduleName:"workbox-cacheable-response",className:"CacheableResponse",funcName:"isResponseCacheable",paramName:"response"});let r=!0;if(this._statuses&&(r=this._statuses.includes(e.status)),this._headers&&r&&(r=Object.keys(this._headers).some(s=>e.headers.get(s)===this._headers[s])),!r){c.groupCollapsed(`The request for '${h(e.url)}' returned a response that does not meet the criteria for being cached.`),c.groupCollapsed("View cacheability criteria here."),c.log("Cacheable statuses: "+JSON.stringify(this._statuses)),c.log("Cacheable headers: "+JSON.stringify(this._headers,null,2)),c.groupEnd();let s={};e.headers.forEach((o,n)=>{s[n]=o}),c.groupCollapsed("View response status and headers here."),c.log(`Response status: ${e.status}`),c.log("Response headers: "+JSON.stringify(s,null,2)),c.groupEnd(),c.groupCollapsed("View full response details here."),c.log(e.headers),c.log(e),c.groupEnd(),c.groupEnd()}return r}};var te=class{constructor(e){this.cacheWillUpdate=async({response:r})=>this._cacheableResponse.isResponseCacheable(r)?r:null,this._cacheableResponse=new x(e)}};function re(t){t.then(()=>{})}var zt=(t,e)=>e.some(r=>t instanceof r),Ze,et;function Jt(){return Ze||(Ze=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Xt(){return et||(et=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}var tt=new WeakMap,be=new WeakMap,rt=new WeakMap,ye=new WeakMap,Ee=new WeakMap;function Yt(t){let e=new Promise((r,s)=>{let o=()=>{t.removeEventListener("success",n),t.removeEventListener("error",a)},n=()=>{r(N(t.result)),o()},a=()=>{s(t.error),o()};t.addEventListener("success",n),t.addEventListener("error",a)});return e.then(r=>{r instanceof IDBCursor&&tt.set(r,t)}).catch(()=>{}),Ee.set(e,t),e}function Zt(t){if(be.has(t))return;let e=new Promise((r,s)=>{let o=()=>{t.removeEventListener("complete",n),t.removeEventListener("error",a),t.removeEventListener("abort",a)},n=()=>{r(),o()},a=()=>{s(t.error||new DOMException("AbortError","AbortError")),o()};t.addEventListener("complete",n),t.addEventListener("error",a),t.addEventListener("abort",a)});be.set(t,e)}var _e={get(t,e,r){if(t instanceof IDBTransaction){if(e==="done")return be.get(t);if(e==="objectStoreNames")return t.objectStoreNames||rt.get(t);if(e==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return N(t[e])},set(t,e,r){return t[e]=r,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function st(t){_e=t(_e)}function er(t){return t===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...r){let s=t.call(se(this),e,...r);return rt.set(s,e.sort?e.sort():[e]),N(s)}:Xt().includes(t)?function(...e){return t.apply(se(this),e),N(tt.get(this))}:function(...e){return N(t.apply(se(this),e))}}function tr(t){return typeof t=="function"?er(t):(t instanceof IDBTransaction&&Zt(t),zt(t,Jt())?new Proxy(t,_e):t)}function N(t){if(t instanceof IDBRequest)return Yt(t);if(ye.has(t))return ye.get(t);let e=tr(t);return e!==t&&(ye.set(t,e),Ee.set(e,t)),e}var se=t=>Ee.get(t);function ot(t,e,{blocked:r,upgrade:s,blocking:o,terminated:n}={}){let a=indexedDB.open(t,e),i=N(a);return s&&a.addEventListener("upgradeneeded",u=>{s(N(a.result),u.oldVersion,u.newVersion,N(a.transaction))}),r&&a.addEventListener("blocked",()=>r()),i.then(u=>{n&&u.addEventListener("close",()=>n()),o&&u.addEventListener("versionchange",()=>o())}).catch(()=>{}),i}function nt(t,{blocked:e}={}){let r=indexedDB.deleteDatabase(t);return e&&r.addEventListener("blocked",()=>e()),N(r).then(()=>{})}var rr=["get","getKey","getAll","getAllKeys","count"],sr=["put","add","delete","clear"],xe=new Map;function at(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(xe.get(e))return xe.get(e);let r=e.replace(/FromIndex$/,""),s=e!==r,o=sr.includes(r);if(!(r in(s?IDBIndex:IDBObjectStore).prototype)||!(o||rr.includes(r)))return;let n=async function(a,...i){let u=this.transaction(a,o?"readwrite":"readonly"),p=u.store;return s&&(p=p.index(i.shift())),(await Promise.all([p[r](...i),o&&u.done]))[0]};return xe.set(e,n),n}st(t=>({...t,get:(e,r,s)=>at(e,r)||t.get(e,r,s),has:(e,r)=>!!at(e,r)||t.has(e,r)}));"use strict";try{self["workbox:expiration:6.5.1"]&&_()}catch(t){}var or="workbox-expiration",V="cache-entries",it=t=>{let e=new URL(t,location.href);return e.hash="",e.href},Ne=class{constructor(e){this._db=null,this._cacheName=e}_upgradeDb(e){let r=e.createObjectStore(V,{keyPath:"id"});r.createIndex("cacheName","cacheName",{unique:!1}),r.createIndex("timestamp","timestamp",{unique:!1})}_upgradeDbAndDeleteOldDbs(e){this._upgradeDb(e),this._cacheName&&nt(this._cacheName)}async setTimestamp(e,r){e=it(e);let s={url:e,timestamp:r,cacheName:this._cacheName,id:this._getId(e)},n=(await this.getDb()).transaction(V,"readwrite",{durability:"relaxed"});await n.store.put(s),await n.done}async getTimestamp(e){let s=await(await this.getDb()).get(V,this._getId(e));return s==null?void 0:s.timestamp}async expireEntries(e,r){let s=await this.getDb(),o=await s.transaction(V).store.index("timestamp").openCursor(null,"prev"),n=[],a=0;for(;o;){let u=o.value;u.cacheName===this._cacheName&&(e&&u.timestamp<e||r&&a>=r?n.push(o.value):a++),o=await o.continue()}let i=[];for(let u of n)await s.delete(V,u.id),i.push(u.url);return i}_getId(e){return this._cacheName+"|"+it(e)}async getDb(){return this._db||(this._db=await ot(or,1,{upgrade:this._upgradeDbAndDeleteOldDbs.bind(this)})),this._db}};var oe=class{constructor(e,r={}){if(this._isRunning=!1,this._rerunRequested=!1,d.isType(e,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"cacheName"}),!(r.maxEntries||r.maxAgeSeconds))throw new l("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor"});r.maxEntries&&d.isType(r.maxEntries,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxEntries"}),r.maxAgeSeconds&&d.isType(r.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxAgeSeconds"}),this._maxEntries=r.maxEntries,this._maxAgeSeconds=r.maxAgeSeconds,this._matchOptions=r.matchOptions,this._cacheName=e,this._timestampModel=new Ne(e)}async expireEntries(){if(this._isRunning){this._rerunRequested=!0;return}this._isRunning=!0;let e=this._maxAgeSeconds?Date.now()-this._maxAgeSeconds*1e3:0,r=await this._timestampModel.expireEntries(e,this._maxEntries),s=await self.caches.open(this._cacheName);for(let o of r)await s.delete(o,this._matchOptions);r.length>0?(c.groupCollapsed(`Expired ${r.length} ${r.length===1?"entry":"entries"} and removed ${r.length===1?"it":"them"} from the '${this._cacheName}' cache.`),c.log(`Expired the following ${r.length===1?"URL":"URLs"}:`),r.forEach(o=>c.log(`    ${o}`)),c.groupEnd()):c.debug("Cache expiration ran and found no entries to remove."),this._isRunning=!1,this._rerunRequested&&(this._rerunRequested=!1,re(this.expireEntries()))}async updateTimestamp(e){d.isType(e,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"updateTimestamp",paramName:"url"}),await this._timestampModel.setTimestamp(e,Date.now())}async isURLExpired(e){if(this._maxAgeSeconds){let r=await this._timestampModel.getTimestamp(e),s=Date.now()-this._maxAgeSeconds*1e3;return r!==void 0?r<s:!0}else throw new l("expired-test-without-max-age",{methodName:"isURLExpired",paramName:"maxAgeSeconds"})}async delete(){this._rerunRequested=!1,await this._timestampModel.expireEntries(1/0)}};function ct(t){d.isType(t,"function",{moduleName:"workbox-core",funcName:"register",paramName:"callback"}),M.add(t),c.log("Registered a callback to respond to quota errors.",t)}var C=class{constructor(e={}){if(this.cachedResponseWillBeUsed=async({event:r,request:s,cacheName:o,cachedResponse:n})=>{if(!n)return null;let a=this._isResponseDateFresh(n),i=this._getCacheExpiration(o);re(i.expireEntries());let u=i.updateTimestamp(s.url);if(r)try{r.waitUntil(u)}catch(p){"request"in r&&c.warn(`Unable to ensure service worker stays alive when updating cache entry for '${h(r.request.url)}'.`)}return a?n:null},this.cacheDidUpdate=async({cacheName:r,request:s})=>{d.isType(r,"string",{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"cacheName"}),d.isInstance(s,Request,{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"request"});let o=this._getCacheExpiration(r);await o.updateTimestamp(s.url),await o.expireEntries()},!(e.maxEntries||e.maxAgeSeconds))throw new l("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor"});e.maxEntries&&d.isType(e.maxEntries,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxEntries"}),e.maxAgeSeconds&&d.isType(e.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxAgeSeconds"}),this._config=e,this._maxAgeSeconds=e.maxAgeSeconds,this._cacheExpirations=new Map,e.purgeOnQuotaError&&ct(()=>this.deleteCacheAndMetadata())}_getCacheExpiration(e){if(e===z.getRuntimeName())throw new l("expire-custom-caches-only");let r=this._cacheExpirations.get(e);return r||(r=new oe(e,this._config),this._cacheExpirations.set(e,r)),r}_isResponseDateFresh(e){if(!this._maxAgeSeconds)return!0;let r=this._getDateHeaderTimestamp(e);if(r===null)return!0;let s=Date.now();return r>=s-this._maxAgeSeconds*1e3}_getDateHeaderTimestamp(e){if(!e.headers.has("date"))return null;let r=e.headers.get("date"),o=new Date(r).getTime();return isNaN(o)?null:o}async deleteCacheAndMetadata(){for(let[e,r]of this._cacheExpirations)await self.caches.delete(e),await r.delete();this._cacheExpirations=new Map}};var nr=(t,e)=>e.some(r=>t instanceof r),ut,dt;function ar(){return ut||(ut=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function ir(){return dt||(dt=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}var lt=new WeakMap,ve=new WeakMap,pt=new WeakMap,Re=new WeakMap,$e=new WeakMap;function cr(t){let e=new Promise((r,s)=>{let o=()=>{t.removeEventListener("success",n),t.removeEventListener("error",a)},n=()=>{r(v(t.result)),o()},a=()=>{s(t.error),o()};t.addEventListener("success",n),t.addEventListener("error",a)});return e.then(r=>{r instanceof IDBCursor&&lt.set(r,t)}).catch(()=>{}),$e.set(e,t),e}function ur(t){if(ve.has(t))return;let e=new Promise((r,s)=>{let o=()=>{t.removeEventListener("complete",n),t.removeEventListener("error",a),t.removeEventListener("abort",a)},n=()=>{r(),o()},a=()=>{s(t.error||new DOMException("AbortError","AbortError")),o()};t.addEventListener("complete",n),t.addEventListener("error",a),t.addEventListener("abort",a)});ve.set(t,e)}var ke={get(t,e,r){if(t instanceof IDBTransaction){if(e==="done")return ve.get(t);if(e==="objectStoreNames")return t.objectStoreNames||pt.get(t);if(e==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return v(t[e])},set(t,e,r){return t[e]=r,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function ht(t){ke=t(ke)}function dr(t){return t===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...r){let s=t.call(ne(this),e,...r);return pt.set(s,e.sort?e.sort():[e]),v(s)}:ir().includes(t)?function(...e){return t.apply(ne(this),e),v(lt.get(this))}:function(...e){return v(t.apply(ne(this),e))}}function lr(t){return typeof t=="function"?dr(t):(t instanceof IDBTransaction&&ur(t),nr(t,ar())?new Proxy(t,ke):t)}function v(t){if(t instanceof IDBRequest)return cr(t);if(Re.has(t))return Re.get(t);let e=lr(t);return e!==t&&(Re.set(t,e),$e.set(e,t)),e}var ne=t=>$e.get(t);function mt(t,e,{blocked:r,upgrade:s,blocking:o,terminated:n}={}){let a=indexedDB.open(t,e),i=v(a);return s&&a.addEventListener("upgradeneeded",u=>{s(v(a.result),u.oldVersion,u.newVersion,v(a.transaction))}),r&&a.addEventListener("blocked",()=>r()),i.then(u=>{n&&u.addEventListener("close",()=>n()),o&&u.addEventListener("versionchange",()=>o())}).catch(()=>{}),i}var pr=["get","getKey","getAll","getAllKeys","count"],hr=["put","add","delete","clear"],De=new Map;function ft(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(De.get(e))return De.get(e);let r=e.replace(/FromIndex$/,""),s=e!==r,o=hr.includes(r);if(!(r in(s?IDBIndex:IDBObjectStore).prototype)||!(o||pr.includes(r)))return;let n=async function(a,...i){let u=this.transaction(a,o?"readwrite":"readonly"),p=u.store;return s&&(p=p.index(i.shift())),(await Promise.all([p[r](...i),o&&u.done]))[0]};return De.set(e,n),n}ht(t=>({...t,get:(e,r,s)=>ft(e,r)||t.get(e,r,s),has:(e,r)=>!!ft(e,r)||t.has(e,r)}));"use strict";try{self["workbox:background-sync:6.5.1"]&&_()}catch(t){}var gt=3,mr="workbox-background-sync",D="requests",B="queueName",Ie=class{constructor(){this._db=null}async addEntry(e){let s=(await this.getDb()).transaction(D,"readwrite",{durability:"relaxed"});await s.store.add(e),await s.done}async getFirstEntryId(){let r=await(await this.getDb()).transaction(D).store.openCursor();return r==null?void 0:r.value.id}async getAllEntriesByQueueName(e){let s=await(await this.getDb()).getAllFromIndex(D,B,IDBKeyRange.only(e));return s||new Array}async getEntryCountByQueueName(e){return(await this.getDb()).countFromIndex(D,B,IDBKeyRange.only(e))}async deleteEntry(e){await(await this.getDb()).delete(D,e)}async getFirstEntryByQueueName(e){return await this.getEndEntryFromIndex(IDBKeyRange.only(e),"next")}async getLastEntryByQueueName(e){return await this.getEndEntryFromIndex(IDBKeyRange.only(e),"prev")}async getEndEntryFromIndex(e,r){let o=await(await this.getDb()).transaction(D).store.index(B).openCursor(e,r);return o==null?void 0:o.value}async getDb(){return this._db||(this._db=await mt(mr,gt,{upgrade:this._upgradeDb})),this._db}_upgradeDb(e,r){r>0&&r<gt&&e.objectStoreNames.contains(D)&&e.deleteObjectStore(D),e.createObjectStore(D,{autoIncrement:!0,keyPath:"id"}).createIndex(B,B,{unique:!1})}};var W=class{constructor(e){this._queueName=e,this._queueDb=new Ie}async pushEntry(e){d.isType(e,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"pushEntry",paramName:"entry"}),d.isType(e.requestData,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"pushEntry",paramName:"entry.requestData"}),delete e.id,e.queueName=this._queueName,await this._queueDb.addEntry(e)}async unshiftEntry(e){d.isType(e,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"unshiftEntry",paramName:"entry"}),d.isType(e.requestData,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"unshiftEntry",paramName:"entry.requestData"});let r=await this._queueDb.getFirstEntryId();r?e.id=r-1:delete e.id,e.queueName=this._queueName,await this._queueDb.addEntry(e)}async popEntry(){return this._removeEntry(await this._queueDb.getLastEntryByQueueName(this._queueName))}async shiftEntry(){return this._removeEntry(await this._queueDb.getFirstEntryByQueueName(this._queueName))}async getAll(){return await this._queueDb.getAllEntriesByQueueName(this._queueName)}async size(){return await this._queueDb.getEntryCountByQueueName(this._queueName)}async deleteEntry(e){await this._queueDb.deleteEntry(e)}async _removeEntry(e){return e&&await this.deleteEntry(e.id),e}};var fr=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"],I=class{constructor(e){d.isType(e,"object",{moduleName:"workbox-background-sync",className:"StorableRequest",funcName:"constructor",paramName:"requestData"}),d.isType(e.url,"string",{moduleName:"workbox-background-sync",className:"StorableRequest",funcName:"constructor",paramName:"requestData.url"}),e.mode==="navigate"&&(e.mode="same-origin"),this._requestData=e}static async fromRequest(e){let r={url:e.url,headers:{}};e.method!=="GET"&&(r.body=await e.clone().arrayBuffer());for(let[s,o]of e.headers.entries())r.headers[s]=o;for(let s of fr)e[s]!==void 0&&(r[s]=e[s]);return new I(r)}toObject(){let e=Object.assign({},this._requestData);return e.headers=Object.assign({},this._requestData.headers),e.body&&(e.body=e.body.slice(0)),e}toRequest(){return new Request(this._requestData.url,this._requestData)}clone(){return new I(this.toObject())}};var wt="workbox-background-sync",gr=60*24*7,Te=new Set,bt=t=>{let e={request:new I(t.requestData).toRequest(),timestamp:t.timestamp};return t.metadata&&(e.metadata=t.metadata),e},ae=class{constructor(e,{forceSyncFallback:r,onSync:s,maxRetentionTime:o}={}){if(this._syncInProgress=!1,this._requestsAddedDuringSync=!1,Te.has(e))throw new l("duplicate-queue-name",{name:e});Te.add(e),this._name=e,this._onSync=s||this.replayRequests,this._maxRetentionTime=o||gr,this._forceSyncFallback=Boolean(r),this._queueStore=new W(this._name),this._addSyncListener()}get name(){return this._name}async pushRequest(e){d.isType(e,"object",{moduleName:"workbox-background-sync",className:"Queue",funcName:"pushRequest",paramName:"entry"}),d.isInstance(e.request,Request,{moduleName:"workbox-background-sync",className:"Queue",funcName:"pushRequest",paramName:"entry.request"}),await this._addRequest(e,"push")}async unshiftRequest(e){d.isType(e,"object",{moduleName:"workbox-background-sync",className:"Queue",funcName:"unshiftRequest",paramName:"entry"}),d.isInstance(e.request,Request,{moduleName:"workbox-background-sync",className:"Queue",funcName:"unshiftRequest",paramName:"entry.request"}),await this._addRequest(e,"unshift")}async popRequest(){return this._removeRequest("pop")}async shiftRequest(){return this._removeRequest("shift")}async getAll(){let e=await this._queueStore.getAll(),r=Date.now(),s=[];for(let o of e){let n=this._maxRetentionTime*60*1e3;r-o.timestamp>n?await this._queueStore.deleteEntry(o.id):s.push(bt(o))}return s}async size(){return await this._queueStore.size()}async _addRequest({request:e,metadata:r,timestamp:s=Date.now()},o){let a={requestData:(await I.fromRequest(e.clone())).toObject(),timestamp:s};switch(r&&(a.metadata=r),o){case"push":await this._queueStore.pushEntry(a);break;case"unshift":await this._queueStore.unshiftEntry(a);break}c.log(`Request for '${h(e.url)}' has been added to background sync queue '${this._name}'.`),this._syncInProgress?this._requestsAddedDuringSync=!0:await this.registerSync()}async _removeRequest(e){let r=Date.now(),s;switch(e){case"pop":s=await this._queueStore.popEntry();break;case"shift":s=await this._queueStore.shiftEntry();break}if(s){let o=this._maxRetentionTime*60*1e3;return r-s.timestamp>o?this._removeRequest(e):bt(s)}else return}async replayRequests(){let e;for(;e=await this.shiftRequest();)try{await fetch(e.request.clone()),c.log(`Request for '${h(e.request.url)}' has been replayed in queue '${this._name}'`)}catch(r){throw await this.unshiftRequest(e),c.log(`Request for '${h(e.request.url)}' failed to replay, putting it back in queue '${this._name}'`),new l("queue-replay-failed",{name:this._name})}c.log(`All requests in queue '${this.name}' have successfully replayed; the queue is now empty!`)}async registerSync(){if("sync"in self.registration&&!this._forceSyncFallback)try{await self.registration.sync.register(`${wt}:${this._name}`)}catch(e){c.warn(`Unable to register sync event for '${this._name}'.`,e)}}_addSyncListener(){"sync"in self.registration&&!this._forceSyncFallback?self.addEventListener("sync",e=>{if(e.tag===`${wt}:${this._name}`){c.log(`Background sync for tag '${e.tag}' has been received`);let r=async()=>{this._syncInProgress=!0;let s;try{await this._onSync({queue:this})}catch(o){if(o instanceof Error)throw s=o,s}finally{this._requestsAddedDuringSync&&!(s&&!e.lastChance)&&await this.registerSync(),this._syncInProgress=!1,this._requestsAddedDuringSync=!1}};e.waitUntil(r())}}):(c.log("Background sync replaying without background sync event"),this._onSync({queue:this}))}static get _queueNames(){return Te}};var F=class{constructor(e,r){this.fetchDidFail=async({request:s})=>{await this._queue.pushRequest({request:s})},this._queue=new ae(e,r)}};async function q(t,e){let r=await globalThis.clients.matchAll({type:"window"});for(let s of r)s.postMessage({type:t,payload:e})}async function Se(t,e,r){(await globalThis.clients.get(t)).postMessage({type:e,payload:r})}async function ie(t,e,r){let s=globalThis._sessions.values();for(let o of s){let n=[o.host,...o.clients];n.map(({id:a})=>a).includes(t)&&n.forEach(a=>{a.postMessage({type:e,payload:r})})}}var ce=class{constructor({cacheName:e,debounceTimeout:r=5e3,saveToCloud:s=!0}){this.cacheName=e,this.debounceTimeout=r,this._savePending=!1,this._saveTimeouts={},this._saveToCloud=s}async _requestBodyToResponse(e){let s=await(await caches.open(this.cacheName)).match(e.url)||{status:200,statusText:"OK",headers:new Headers({"content-type":"application/x-gambl; charset=utf-8"})};s.headers.set("Date",new Date().toUTCString());let o=e.clone();return new Response(o.body,s)}async _cacheResponse(e,r){let s=r.clone();await(await caches.open(this.cacheName)).put(e,s)}debounceSave(e,r){this._savePending||(ie(e,"FILE_SAVE_PENDING",{url:r.url}),this._savePending=!0),clearTimeout(this._saveTimeouts[r.url]),this._saveTimeouts[r.url]=setTimeout(async()=>{let s=new Headers(r.headers);s.set("content-type","application/x-gambl; charset=utf-8");let o=new Request(r,{headers:s}),n=await fetch(o);n.ok?ie(e,"FILE_SAVE_SUCCESS",{url:r.url}):ie(e,"FILE_SAVE_ERROR",{error:n.statusText}),this._savePending=!1,delete this._saveTimeouts[r.url]},this.debounceTimeout)}async requestWillFetch({request:e,event:r}){return this._cacheResponse(e.url,await this._requestBodyToResponse(e)),this._saveToCloud&&this.debounceSave(r.clientId,e),new Request("manifest.json")}};var ue=class{async cacheWillUpdate({response:e}){return(await e.clone().text()).includes("<Code>AccessDenied</Code>")?null:e}async handlerWillRespond({response:e}){return(await e.clone().text()).includes("<Code>AccessDenied</Code>")?new Response("File not found",{status:404}):e}};var de=class{constructor({cacheName:e}){this.cacheName=e}async cacheWillUpdate({request:e,response:r,event:s}){let n=await(await caches.open(this.cacheName)).match(e);if(!n)return r;let a=await(n==null?void 0:n.text()),i=await r.clone().text();return a===i||i.includes("AccessDenied")?null:(s.clientId?Se(s.clientId,"FILE_CACHE_UPDATED",{cacheName:this.cacheName,updatedURL:e.url}):q("FILE_CACHE_UPDATED",{cacheName:this.cacheName,updatedURL:e.url}),r)}async cachedResponseWillBeUsed({cacheName:e,request:r,cachedResponse:s,event:o}){return s?(o.clientId?Se(o.clientId,"FILE_CACHE_USED",{cacheName:e,url:r.url}):q("FILE_CACHE_USED",{cacheName:e,url:r.url}),s):null}};var wr=(t,e)=>e.some(r=>t instanceof r),yt,Et;function br(){return yt||(yt=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function yr(){return Et||(Et=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}var _t=new WeakMap,Ce=new WeakMap,xt=new WeakMap,je=new WeakMap,Oe=new WeakMap;function Er(t){let e=new Promise((r,s)=>{let o=()=>{t.removeEventListener("success",n),t.removeEventListener("error",a)},n=()=>{r(R(t.result)),o()},a=()=>{s(t.error),o()};t.addEventListener("success",n),t.addEventListener("error",a)});return e.then(r=>{r instanceof IDBCursor&&_t.set(r,t)}).catch(()=>{}),Oe.set(e,t),e}function _r(t){if(Ce.has(t))return;let e=new Promise((r,s)=>{let o=()=>{t.removeEventListener("complete",n),t.removeEventListener("error",a),t.removeEventListener("abort",a)},n=()=>{r(),o()},a=()=>{s(t.error||new DOMException("AbortError","AbortError")),o()};t.addEventListener("complete",n),t.addEventListener("error",a),t.addEventListener("abort",a)});Ce.set(t,e)}var Ae={get(t,e,r){if(t instanceof IDBTransaction){if(e==="done")return Ce.get(t);if(e==="objectStoreNames")return t.objectStoreNames||xt.get(t);if(e==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return R(t[e])},set(t,e,r){return t[e]=r,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function Nt(t){Ae=t(Ae)}function xr(t){return t===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...r){let s=t.call(le(this),e,...r);return xt.set(s,e.sort?e.sort():[e]),R(s)}:yr().includes(t)?function(...e){return t.apply(le(this),e),R(_t.get(this))}:function(...e){return R(t.apply(le(this),e))}}function Nr(t){return typeof t=="function"?xr(t):(t instanceof IDBTransaction&&_r(t),wr(t,br())?new Proxy(t,Ae):t)}function R(t){if(t instanceof IDBRequest)return Er(t);if(je.has(t))return je.get(t);let e=Nr(t);return e!==t&&(je.set(t,e),Oe.set(e,t)),e}var le=t=>Oe.get(t);function pe(t,e,{blocked:r,upgrade:s,blocking:o,terminated:n}={}){let a=indexedDB.open(t,e),i=R(a);return s&&a.addEventListener("upgradeneeded",u=>{s(R(a.result),u.oldVersion,u.newVersion,R(a.transaction))}),r&&a.addEventListener("blocked",()=>r()),i.then(u=>{n&&u.addEventListener("close",()=>n()),o&&u.addEventListener("versionchange",()=>o())}).catch(()=>{}),i}var vr=["get","getKey","getAll","getAllKeys","count"],Rr=["put","add","delete","clear"],Le=new Map;function vt(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(Le.get(e))return Le.get(e);let r=e.replace(/FromIndex$/,""),s=e!==r,o=Rr.includes(r);if(!(r in(s?IDBIndex:IDBObjectStore).prototype)||!(o||vr.includes(r)))return;let n=async function(a,...i){let u=this.transaction(a,o?"readwrite":"readonly"),p=u.store;return s&&(p=p.index(i.shift())),(await Promise.all([p[r](...i),o&&u.done]))[0]};return Le.set(e,n),n}Nt(t=>({...t,get:(e,r,s)=>vt(e,r)||t.get(e,r,s),has:(e,r)=>!!vt(e,r)||t.has(e,r)}));var qe=["init","import","session-starting","udm:add-meter"],$r=["sensor-added"],T=class extends EventTarget{static get db(){return pe("serviceWorkerSessions",1,{upgrade(e){e.createObjectStore("sessions",{keyPath:"sessionid"})}})}constructor(e,r,s={}){super();this.sessionid=e,this.serviceworker=r,this.clients=[],this.hostOnlyResponses={},this.messages={},this.messageId=1,this.archiveRequests={},this.deviceRequest=null,s.rpcLogger&&(this.rpcLogger=s.rpcLogger),s.serialized&&(this._deserializing=!0,this._deserialize(s.serialized))}get serialized(){var e;return{sessionid:this.sessionid,clients:this.clients.map(r=>r.id),host:(e=this.host)==null?void 0:e.id,wasmReady:this._wasmReady}}get ready(){return this._deserializing?new Promise(e=>{this.addEventListener("deserialized",()=>e(!0),{once:!0})}):Promise.resolve(!0)}async _deserialize(e){let r=await this.serviceworker.clients.matchAll();this.clients=e.clients.map(s=>r.find(o=>o.id===s)),this.host=r.find(s=>s.id===e.host),this._wasmReady=e.wasmReady,delete this._deserializing,this.dispatchEvent(new Event("deserialized"))}rpcLog(){this.rpcLogger?console.log(this.rpcLogger.getLogString()):console.error("No rpcLogger set")}addDevice({data:e,source:r}){this.deviceRequest=r,this.host.postMessage(e)}addDeviceResponse({data:e}){this.deviceRequest.postMessage(e),this.deviceRequest=null}archiveRequest({data:e,source:r}){this.archiveRequests[e.id]=r,this.host.postMessage(e)}archiveResponse({data:e}){let r=this.archiveRequests[e.id];delete this.archiveRequests[e.id],r.postMessage(e)}nativeResponse({data:e,source:r}){let s=typeof e.message=="string"?JSON.parse(e.message):e.message,o=this.messages[s.id];o&&(qe.includes(o.method)&&(r.id===this.host.id?(this.hostOnlyResponses[o.method]=s,this.dispatchEvent(new Event(`host-only-response-${o.method}`))):s=this.hostOnlyResponses[o.method]),s.id=o.id),[...this.clients,this.host].forEach(n=>{var a,i,u,p;[void 0,0].includes(e.message.id)||(o==null?void 0:o.sourceId)===n.id||$r.includes(s.method)?(o?((!qe.includes(o.method)||r.id===this.host.id)&&this.rpcLogger&&this.rpcLogger.logResponse("HOST","ServiceWorker",(a=s==null?void 0:s.method)!=null?a:o.method,s),this.rpcLogger&&this.rpcLogger.logResponse("ServiceWorker",((i=o==null?void 0:o.sourceId)!=null?i:r.id)===this.host.id?"HOST":`CLIENT_${this._clientIndex(n)}`,(u=s==null?void 0:s.method)!=null?u:o.method,s)):(this.rpcLogger&&this.rpcLogger.logNotification("HOST","ServiceWorker",s),this.rpcLogger&&this.rpcLogger.logNotification("ServiceWorker",((p=o==null?void 0:o.sourceId)!=null?p:r.id)===this.host.id?"HOST":`CLIENT_${this._clientIndex(n)}`,s)),n.postMessage(O(g({},e),{message:s,type:"NATIVE_RESPONSE"}))):o||(this.rpcLogger&&(this.rpcLogger.logResponse("HOST","ServiceWorker",s==null?void 0:s.method,s),this.rpcLogger.logResponse("ServiceWorker","HOST",s==null?void 0:s.method,s)),this.host.postMessage(O(g({},e),{message:s,type:"NATIVE_RESPONSE"})))}),o&&delete this.messages[s.id]}_clientIndex(e){return this.clients.findIndex(r=>r.id===e.id)}async nativeMessage({data:e,source:r}){let s=typeof e.message=="string"?JSON.parse(e.message):e.message;if(!!s){if(this.rpcLogger&&this.rpcLogger.logRequest(r.id===this.host.id?"HOST":`CLIENT_${this._clientIndex(r)}`,"ServiceWorker",s),s.id&&!s.result&&(this.messages[this.messageId]={id:s.id,sourceId:r.id,method:s.method},s.id=this.messageId,this.messageId++),qe.includes(s.method)&&r.id!==this.host.id){await new Promise(n=>{this.hostOnlyResponses[s.method]?n():this.addEventListener(`host-only-response-${s.method}`,n,{once:!0})});let o=O(g({},this.hostOnlyResponses[s.method]),{id:s.id});this.nativeResponse({data:O(g({},e),{message:o}),source:r});return}this.rpcLogger&&this.rpcLogger.logRequest("ServiceWorker","HOST",s),this.host.postMessage(O(g({},e),{message:JSON.stringify(s),type:"NATIVE_MESSAGE"}))}}wasmReady(){this._wasmReady=!0,[this.host,...this.clients].filter(Boolean).forEach(e=>{e.postMessage({type:"WASM_READY"})})}async join(e){return await this.clientCleanup(),this.host?this.clients.push(e):this.host=e,this._notifyJoined(e),T.db.then(r=>{r.put("sessions",this.serialized),this.dispatchEvent(new Event("session-saved"))}).catch(r=>{console.log(r)}),this.host.id===e.id}async clientCleanup(){var r;let e=(await this.serviceworker.clients.matchAll({includeUncontrolled:!0})).map(s=>s.id);e.includes((r=this.host)==null?void 0:r.id)||(delete this.host,this._wasmReady=!1,this.rpcLogger&&this.rpcLogger.clearLog()),this.clients=this.clients.filter(s=>e.includes(s.id)),T.db.then(s=>{this.host?s.put("sessions",this.serialized):s.delete("sessions",this.sessionid)})}_notifyJoined(e){e.postMessage({type:"JOINED",host:this.host.id===e.id}),this._wasmReady&&e.postMessage({type:"WASM_READY"})}};var Tt=pe("serviceWorkerSources",1,{upgrade(t){t.createObjectStore("sources")}});async function Cr(){if(globalThis._rehydrating)throw new Error("Rehydration in process");globalThis._rehydrating=!0,await Promise.all([Tt.then(async t=>{let e=(await globalThis.clients.matchAll()).map(s=>s.id),r=await t.getAllKeys("sources");return Promise.all(r.map(async s=>{e.includes(s)?globalThis._sources.set(s,await t.get("sources",s)):t.delete("sources",s)}))}),globalThis.clients.matchAll().then(async t=>{let e=t.map(n=>n.id),r=await T.db,o=(await r.getAll("sessions")).filter(n=>(e.includes(n.host)||r.delete("sessions",n.sessionid),e.includes(n.host)));return Promise.all(o.map(async n=>{let a=!1;if(["canary","development"].includes("release")){let{RPCLogger:u}=await Promise.resolve().then(()=>(Ve(),Ue));a=new u}let i=new T(n.sessionid,globalThis,{serialized:n,rpcLogger:a});return globalThis._sessions.set(n.sessionid,i),i.ready}))})]),globalThis._rehydrating=!1}function St(){globalThis._sessions=new Map,globalThis._sources=new Map;let t=r=>r.toLowerCase().replace(/([-_][a-z])/g,s=>s.toUpperCase().replace("-","").replace("_",""));async function e(){Array.from(globalThis._sessions.values()).forEach(async s=>{await s.clientCleanup(),!s.host&&!s.clients.length&&globalThis._sessions.delete(s.sessionid)})}globalThis.addEventListener("message",async r=>{var a,i,u,p,b;let{data:s={},source:o}=r,{type:n}=s;if(!globalThis._rehydrating)if(globalThis._sessions.size||await Cr(),n==="SKIP_WAITING")await globalThis.skipWaiting(),s.claim&&globalThis.clients.claim();else if(n==="FIRST_INSTALL")globalThis.clients.claim();else if(n==="JOIN"){globalThis._sources.set(o.id,(i=(a=s.sessionId)!=null?a:s.experimentId)!=null?i:o.id),(await Tt).put("sources",(p=(u=s.sessionId)!=null?u:s.experimentId)!=null?p:o.id,o.id);let m=globalThis._sources.get(o.id);if(!globalThis._sessions.has(m)){let j;if(["canary","development"].includes("release")){let{RPCLogger:Ot}=await Promise.resolve().then(()=>(Ve(),Ue));j=new Ot}globalThis._sessions.set(m,new T(m,globalThis,{rpcLogger:j}))}let f=globalThis._sessions.get(m);await f.join(o),await e(),globalThis._sessions.has(m)||globalThis._sessions.set(m,f)}else t(n)in((b=globalThis._sessions.get(globalThis._sources.get(o.id)))!=null?b:{})&&globalThis._sessions.get(globalThis._sources.get(o.id))[t(n)]({data:s,source:o})})}function Be({url:t,revision:e}){return`${globalThis.location.origin}/${t}?__vst_revision=${e}`}function Ct(t,e="precache-v1"){let r=new Map(t.map(({url:n,revision:a})=>[`/${n}`,Be({url:n,revision:a})])),s=new Set(t.map(Be)),o=async()=>{q("PRECACHE_STARTING");let n=await caches.open(e),a=await Promise.allSettled(t.map(async({url:i,revision:u})=>{let p=Be({url:i,revision:u});return await n.match(p)?null:fetch(p).then(m=>{let f=m.clone();return new x({statuses:[0,200]}).isResponseCacheable(f)?n.put(p,m):null})}));return q("PRECACHE_FINISHED"),a};globalThis.addEventListener("install",n=>globalThis.registration.active?n.waitUntil(o()):setTimeout(o,1e3)),globalThis.addEventListener("activate",n=>{n.waitUntil((async()=>{let a=await caches.open(e),u=(await a.keys()).filter(p=>!s.has(p.url));return Promise.all(u.map(p=>a.delete(p)))})())}),t.length&&y(({url:n})=>r.has(n.pathname)||n.pathname==="/",new L({cacheName:e,plugins:[{cacheKeyWillBeUsed:({request:n})=>{let a=new URL(n.url),i=a.pathname==="/"?"/index.html":a.pathname,u=`${r.get(i)}`;return u!=null?u:null}},new te({statuses:[0,200]})]}))}var We=class{async requestWillFetch({request:e}){let r=new Headers(e.headers);return r.set("x-forwarded-for",globalThis.location.origin),new Request(e,{headers:r})}};var he="experiment-configuration-cache",Fe="session-cache";St();Ct([]);y(/https:\/\/(ga-experiment-library.s3-us-west-2.amazonaws.com|experiments.graphicalanalysis.com)\/.*experiment-manifest.json/,new ee({cacheName:"manifest-cache",fetchOptions:{headers:{pragma:"no-cache","cache-control":"no-cache"}},plugins:[new x({statuses:[0,200]}),new C({maxAgeSeconds:60*60*24*365,maxEntries:1})]}));y(/https:\/\/(ga-experiment-library.s3-us-west-2.amazonaws.com|experiments.graphicalanalysis.com)\/.*\.gambl/,new L({cacheName:"experiment-cache",plugins:[new x({statuses:[0,200]}),new C({maxAgeSeconds:60*60*24*365,maxEntries:60})]}));y(new RegExp("https://xvfdsz97i8.execute-api.us-west-2.amazonaws.com/default/lookup-key"),new S({plugins:[new We]}),"POST");async function jr({data:{type:t}}){!t.includes("DEMO-MODE")||(globalThis.demoMode=t==="DEMO-MODE")}var jt=t=>({cachedResponseWillBeUsed:async({request:e,cachedResponse:r})=>globalThis.demoMode?t?fetch(e):new Response(null,{status:404}):r});y(new RegExp("https://sessions.graphicalanalysis.app"),new U({cacheName:Fe,plugins:[new de({cacheName:Fe}),new ue,new x({statuses:[0,200]}),new C({maxAgeSeconds:60*60*24*90,maxEntries:60}),jt()]}));y(new RegExp("https://2e1cohznn2.execute-api.us-west-2.amazonaws.com/beta"),new U({cacheName:he,plugins:[new de({cacheName:he}),new ue,new x({statuses:[0,200]}),new C({maxAgeSeconds:60*60*24*90,maxEntries:60}),jt(!0)]}));y(new RegExp("https://sessions.graphicalanalysis.app"),new S({plugins:[new F("session-sync-queue",{maxRetentionTime:24*60}),new ce({cacheName:Fe,saveToCloud:!1})]}),"POST");y(new RegExp("https://2e1cohznn2.execute-api.us-west-2.amazonaws.com/beta"),new S({plugins:[new F("experiment-sync-queue",{maxRetentionTime:24*60}),new ce({cacheName:he})]}),"POST");y(new RegExp("https://2e1cohznn2.execute-api.us-west-2.amazonaws.com/beta"),new S({plugins:[{requestWillFetch:async({request:t})=>(await(await caches.open(he)).delete(t,{ignoreMethod:!0}),t)}]}),"DELETE");globalThis.addEventListener("message",jr);})();
